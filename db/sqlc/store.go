package generated_db

import (
	"context"
	"database/sql"
	"fmt"
)

// Store defines all functions to execute db queries and transactions
// that must be implemented both by a real database store (like SQLStore)
// and a mock store for testing.
type Store interface {
	Querier
	TransferMoneyTxn(ctx context.Context, arg TransferTxParams) (TransferMoneyTxnResult, error)
}

// SQLStore provides all functions to execute SQL queries and transactions
// It's the real implementation of the Store interface that actually
// interacts with the database.
type SQLStore struct {
	db *sql.DB
	// Queries is a struct that contains all the auto-generated queries
	// for the database operations, generated by sqlc.
	// But the Queries only contains the individual queries to the database in
	// the auto-generated methods and not the transactional function.
	// So, we need to create a new struct that contains the transactional functions.
	*Queries
}

// NewStore creates a new SQLStore.
func NewStore(db *sql.DB) Store {
	return &SQLStore{
		db:      db,
		Queries: New(db),
	}
}

// This takes a context and a call back function that takes a Queries object and returns an error.
// This function will start a new database transaction, create a new Queries object
// with that transaction and call the callback function with that Queries object.
// If the callback function returns an error, the transaction will be rolled back.
// If the callback function returns nil, the transaction will be committed.
// This function is unexported (and starts with the lower case letter e) because it
// is only used internally and we don't want external packages to call it directly.
func (store *SQLStore) execTxn(ctx context.Context, fn func(q *Queries) error) error {
	tx, err := store.db.BeginTx(ctx, &sql.TxOptions{})
	if err != nil {
		return err
	}

	// This will return the Queries object with the transaction.
	// So now we have the queries inside the methods of Queries object
	// that runs within the transaction.
	// We can all the input function f with the new Queries object.
	// Note that this Queries object is created from a single database transaction.
	// So all of it's methods that we can call like queries.CreateTransfer, queries.GetAccount etc
	// will all run within that same transaction.
	queries := New(tx)

	// The callback function fn will use the Queries object (which now uses the transaction
	// created above to perform the database operations) to perform queries and execute
	// sql statements against the database. So if any of the queries or operations fail
	// in those operations in the callback fn function, we will rollback the transaction.
	err = fn(queries)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("transaction error: %v, rollback error: %v", err, rbErr)
		}
		return err
	}

	// If all operations and queries in the transaction are successful, we commit the transaction.
	return tx.Commit()
}

// TransferMoneyTxnParams contains the input parameters of the transfer transaction
type TransferTxParams struct {
	FromAccountID int64 `json:"from_account_id"`
	ToAccountID   int64 `json:"to_account_id"`
	Amount        int64 `json:"amount"`
}

// TransferMoneyTxnResult is the result of the transfer transaction
type TransferMoneyTxnResult struct {
	Transfer    Transfer `json:"transfer"`     // The transfer object created after the money transfer
	FromAccount Account  `json:"from_account"` // The account from which the money was transferred
	ToAccount   Account  `json:"to_account"`   // The account to which the money was transferred
	FromEntry   Entry    `json:"from_entry"`   // The entry created for the from account with -ve amount
	ToEntry     Entry    `json:"to_entry"`     // The entry created for the to account with +ve amount
}

func (store *SQLStore) TransferMoneyTxn2(ctx context.Context, args TransferTxParams) (TransferMoneyTxnResult, error) {
	var result TransferMoneyTxnResult

	// We use the execTxn function to start a new transaction and execute the callback function.
	// The callback function will use the Queries object to perform the database operations.
	err := store.execTxn(ctx, func(q *Queries) error {

		// * First query: Create a new transfer record in the database.
		createTransferParams := CreateTransferParams{
			FromAccountID: args.FromAccountID,
			ToAccountID:   args.ToAccountID,
			Amount:        args.Amount,
		}
		transfer, err := q.CreateTransfer(ctx, createTransferParams)
		if err != nil {
			return err
		}
		result.Transfer = transfer

		// * Second query: Add a new entry for the from account with -ve amount.
		// Add a new entry for the from account with -ve amount.
		fromEntryParams := CreateEntryParams{
			AccountID: args.FromAccountID,
			Amount:    -args.Amount,
		}
		fromEntry, err := q.CreateEntry(ctx, fromEntryParams)

		if err != nil {
			return err
		}

		result.FromEntry = fromEntry

		// * Third query: Add a new entry for the to account with +ve amount.
		// Add a new entry for the to account with +ve amount.
		toEntryParams := CreateEntryParams{
			AccountID: args.ToAccountID,
			Amount:    args.Amount,
		}
		toEntry, err := q.CreateEntry(ctx, toEntryParams)
		if err != nil {
			return err
		}

		result.ToEntry = toEntry

		// * Fourth query: Update the account balance for the from account.

		// Get the "from account" balance -> Update the "from account" balance
		// fromAccount, err := q.GetAccountForUpdate(ctx, args.FromAccountID)
		// if err != nil {
		// 	return err
		// }

		// Update the "from account" balance
		// updateFromAccountParams := UpdateAccountParams{
		// 	ID:      args.FromAccountID,
		// 	Balance: fromAccount.Balance - args.Amount,
		// }
		// fromAccountUpdated, err := q.UpdateAccount(ctx, updateFromAccountParams)

		// if err != nil {
		// 	return err
		// }

		// Updating balance without reading the account first
		fromAccountUpdated, err := q.AddAccountBalance(ctx, AddAccountBalanceParams{
			ID:     args.FromAccountID,
			Amount: args.Amount * -1,
		})
		if err != nil {
			return err
		}

		result.FromAccount = fromAccountUpdated

		// * Fifth query: Update the account balance for the to account.
		// Get the "to account" balance -> Update the "to account" balance

		// toAccount, err := q.GetAccountForUpdate(ctx, args.ToAccountID)
		// if err != nil {
		// 	return err
		// }
		// Update the "to account" balance
		// updateToAccountParams := UpdateAccountParams{
		// 	ID:      args.ToAccountID,
		// 	Balance: toAccount.Balance + args.Amount,
		// }
		// toAccountUpdated, err := q.UpdateAccount(ctx, updateToAccountParams)

		// if err != nil {
		// 	return err
		// }

		// Updating balance without reading the account first
		toAccountUpdated, err := q.AddAccountBalance(ctx, AddAccountBalanceParams{
			ID:     args.ToAccountID,
			Amount: args.Amount,
		})

		if err != nil {
			return err
		}

		result.ToAccount = toAccountUpdated

		return nil
	})

	return result, err
}

func (store *SQLStore) TransferMoneyTxn(ctx context.Context, arg TransferTxParams) (TransferMoneyTxnResult, error) {
	var result TransferMoneyTxnResult

	err := store.execTxn(ctx, func(q *Queries) error {
		var err error

		result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams{
			FromAccountID: arg.FromAccountID,
			ToAccountID:   arg.ToAccountID,
			Amount:        arg.Amount,
		})
		if err != nil {
			return err
		}

		result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams{
			AccountID: arg.FromAccountID,
			Amount:    -arg.Amount,
		})
		if err != nil {
			return err
		}

		result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams{
			AccountID: arg.ToAccountID,
			Amount:    arg.Amount,
		})
		if err != nil {
			return err
		}

		// To prevent deadlocks by ensuring that transactions always acquire
		// locks on the accounts in a consistent order.
		// We are ensuring that the account with the lower ID is always locked first
		// irrespective of the money transfer direction.
		if arg.FromAccountID < arg.ToAccountID { // fromAccountID < toAccountID
			result.FromAccount, result.ToAccount, err = addMoney(ctx, q, arg.FromAccountID, -arg.Amount, arg.ToAccountID, arg.Amount)
		} else { // toAccountID < fromAccountID, so we lock the toAccount first
			result.ToAccount, result.FromAccount, err = addMoney(ctx, q, arg.ToAccountID, arg.Amount, arg.FromAccountID, -arg.Amount)
		}

		return err
	})

	return result, err
}

func addMoney(
	ctx context.Context,
	q *Queries,
	accountID1 int64,
	amount1 int64,
	accountID2 int64,
	amount2 int64,
) (account1 Account, account2 Account, err error) {
	account1, err = q.AddAccountBalance(ctx, AddAccountBalanceParams{
		ID:     accountID1,
		Amount: amount1,
	})
	if err != nil {
		return
	}

	account2, err = q.AddAccountBalance(ctx, AddAccountBalanceParams{
		ID:     accountID2,
		Amount: amount2,
	})
	return
}
